<?phpnamespace Aspect\Reflection;use Aspect\Annotations\MethodAnnotation;/** * Improved Reflection Class */class ReflectionClass extends \ReflectionClass{	const EOL = PHP_EOL;	const INDENT = "    ";	protected $_annotationReader;	public function __toString()	{		$str = '';		// Namespace		$str .= $this->toStringNamespace();		// Docblock		$str .= $this->toStringDocComment($this);		// Class/interface declaration        if ($this->isInterface()) {            $str .= 'interface ';        } else {            $str .= 'class ';        }        $str .= $this->getShortName();        // Parent class        if ($this->getParentClass() != null) {            $str .= ' extends ' . '\\' . $this->getParentClass()->getName();        }        // Interfaces        if (count($this->getInterfaceNames()) > 0) {            $str .= self::EOL . self::INDENT . 'implements ';            $interfaces = $this->getInterfaceNames();            $i = 0;            foreach ($interfaces as $interfaceName) {                if ($i > 0) {                    $str .= ', ';                }                $str .=  '\\' . $interfaceName;                $i++;            }        }        $str .= self::EOL.'{'.self::EOL.self::EOL;		// Constants		$constants = $this->getConstants();		foreach ($constants as $name => $value) {			$str .= self::INDENT . 'const ' . $name;			$str .= ' = ' . var_export($value, true);    		$str .= ';' . self::EOL . self::EOL;		}		// Properties		$properties = $this->getProperties();		$defaultValues = $this->getDefaultProperties();		foreach ($properties as $property) {            // Exclude inherited properties            if ($property->getDeclaringClass()->getName() == $this->getName()) {                // Property with default value                if (array_key_exists($property->getName(), $defaultValues)                        && ($defaultValues[$property->getName()] != null)) {                    $str .= $this->toStringProperty($property, true, $defaultValues[$property->getName()]);                } else {                    $str .= $this->toStringProperty($property, false);                }            }		}		// Methods		$methods = $this->getMethods();		foreach ($methods as $method) {            // Exclude inherited methods            if ($method->getDeclaringClass()->getName() == $this->getName()) {                $str .= $this->toStringMethod($method);            }		}		// End class declaration		$str .= '}'.self::EOL;		return $str;	}	protected function toStringNamespace()	{		$str = '';		if ($this->getNamespaceName() != '') {			$str .= 'namespace ' . $this->getNamespaceName() . ';' . self::EOL . self::EOL;		}		return $str;	}	protected function toStringDocComment($object, $indentation = '')	{		$str = '';		if ($object->getDocComment() != '') {			$str .= $indentation;			$str .= $object->getDocComment() . self::EOL;		}		return $str;	}	protected function toStringProperty(\ReflectionProperty $property, $hasDefaultValue, $defaultValue = null)	{		$str = '';		$str .= $this->toStringDocComment($property, self::INDENT);		$str .= self::INDENT;		if ($property->isPrivate()) {			$str .= 'private ';		}		if ($property->isProtected()) {			$str .= 'protected ';		}		if ($property->isPublic()) {			$str .= 'public ';		}		if ($property->isStatic()) {			$str .= 'static ';		}		$str .= '$'.$property->getName();		if ($hasDefaultValue) {			$str .= ' = '.var_export($defaultValue, true);		}		$str .= ';'.self::EOL.self::EOL;		return $str;	}	protected function toStringMethod(\ReflectionMethod $method)	{		$str = '';		$str .= $this->toStringDocComment($method, self::INDENT);		$str .= self::INDENT;		if ($method->isPrivate()) {			$str .= 'private ';		}		if ($method->isProtected()) {			$str .= 'protected ';		}		if ($method->isPublic()) {			$str .= 'public ';		}		if ($method->isStatic()) {			$str .= 'static ';		}		$str .= 'function '.$method->getName().'(';		// Parameters		$parameters = $method->getParameters();		for ($i = 0; $i < count($parameters); $i++) {		    $parameter = $parameters[$i];		    if ($i > 0) {		        $str .= ', ';		    }		    if ($parameter->isArray()) {		        $str .= 'array ';		    }		    $parameterClass = $parameter->getClass();		    if ($parameterClass) {		        $str .= $parameterClass->getName().' ';		    }		    if ($parameter->isPassedByReference()) {		        $str .= '&';		    }		    $str .= '$'.$parameter->getName();		    if ($parameter->isDefaultValueAvailable()) {		        $str .= ' = '.var_export($parameter->getDefaultValue(), true);		    }		}		$str .= ')';        if ($method->isAbstract()) {            return $str . ';' . self::EOL . self::EOL;        } else {            $str .= self::EOL;        }		$str .= self::INDENT.'{'.self::EOL;                // Code injection		$classAnnotations = $this->getAnnotationReader()->getMethodAnnotations($method);		foreach ($classAnnotations as $annotation) {		    if ($annotation instanceof MethodAnnotation) {		        $pointcutClassName = $annotation->getMethodPointcut();		        $str .= self::INDENT.self::INDENT.		            '$pointcut = new '.$pointcutClassName.'();'.self::EOL;		        $str .= self::INDENT.self::INDENT.		            '$pointcut->beforeMethod($this, __METHOD__, func_get_args());'                            .self::EOL;		    }		}		// Method content		$content = $this->getMethodContent($method);		if ($content != '') {		    $str .= self::INDENT.self::INDENT.$content.self::EOL;		}        // Code injection		foreach ($classAnnotations as $annotation) {		    if ($annotation instanceof MethodAnnotation) {		        $pointcutClassName = $annotation->getMethodPointcut();		        $str .= self::INDENT.self::INDENT.		            '$pointcut->afterMethod($this, __METHOD__, func_get_args());'                            .self::EOL;		    }		}		// End of method		$str .= self::INDENT.'}'.self::EOL.self::EOL;		return $str;	}	/**	 * Annotation reader	 * @return	 */	protected function getAnnotationReader()	{	    if ($this->_annotationReader == null) {            $this->_annotationReader = new \Doctrine\Common\Annotations\AnnotationReader();            $this->_annotationReader->setAnnotationNamespaceAlias(            	'\Aspect\Annotations\Validation\\', 'Validation');            $this->_annotationReader->setAnnotationNamespaceAlias(            	'\Aspect\Annotations\\', '');	    }        return $this->_annotationReader;	}	/**	 * @return string	 */	public function getMethodContent(\ReflectionMethod $method)	{		$fileName = $this->getFileName();		$handle = fopen($fileName, 'r');		$startLine = $method->getStartLine();		$endLine = $method->getEndLine();		$content = '';		// Read file		$lineNumber = 0;		while (($line = fgets($handle)) && ($lineNumber <= $endLine)) {		    $lineNumber++;		    if (($lineNumber >= $startLine) && ($lineNumber <= $endLine)) {		        $content .= $line;		    }		}		fclose($handle);		// Keep only the content of the method, strip out the method declaration		$startPos = strpos($content, '{') + 1;		$endPos = strrpos($content, '}');		$content = substr($content, $startPos, $endPos - $startPos);		// Remove empty lines		$content = trim($content);	    return $content;	}}